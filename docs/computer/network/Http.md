---
title: HTTP/HTTPS协议
author: RoleTang
date: '2022-09-10'
---

## HTTP/HTTPS

`http`: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
 `https`:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层（或者TSL）进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

**https的实现**

- 对称加密：采用协商的密钥对数据加密（传输数据，对称加密开销更小）- 数据传输
- 非对称加密：实现身份认证和密钥协商 - 验证服务器端身份
- 摘要算法：验证信息的完整性，利用哈希算法、散列函数等对内容生成一个唯一的认证序列，再通过验证序列的正确性便可知数据是否被篡改。
- 数字签名：身份验证。签名由发送者发出，是他的凭证，因为是由他的私钥加密，对应的就可以用他的公钥解密。之后便可以拿到对应的摘要再进行对比。但我们需要查看对应的公钥是否就是这个发送者的，此时便可以使用ca认证

ca证书的验证

- 客户端得到服务端返回的证书，通过读取得到 **服务端证书的发布机构（Issuer）**

- 客户端去操作系统查找这个发布机构的的证书，如果是不是根证书就继续递归下去 **直到拿到根证书**。

- 用 **根证书的公钥** 去 **解密验证** 上一层证书的**合法性**，再拿上一层证书的公钥去验证更上层证书的合法性；递归回溯。

- 最后验证服务器端的证书是 **可信任** 的。

- 同时证书会包含当前请求创建证书的域名，如果当前的域名和客户端请求的域名不一致的话也代表是数据被劫持了。

![ca认证](/network/ca.png)


**HTTPS请求过程**：

1. Client发起一个HTTPS请求，连接443端口，并携带自己可以进行连接的SSL、TLS版本号、支持的加密算法等。这个过程可以理解成是 **「请求公钥的过程」**。

2. Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。

3. 浏览器本身会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名（公钥证书）进行解密。

   根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。

   通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。

4. 在安全拿到「服务器公钥」后，客户端Client随机生成一个「对称密钥」，使用「服务器公钥」（证书的公钥）加密这个「对称密钥」，发送给Server(服务器)。

5. Server(服务器)通过自己的私钥，对信息解密，至此得到了「对称密钥」**，此时两者都拥有了相同的**「对称密钥」。


**问：为什么抓包工具还可以获取到https协议传输的内容？**

  因为对于抓包工具而言是用户主动安装到客户端的，所以用户需要在安装的时候同时安装对应的抓包工具的证书并信任。

  在https传输信息的时候，抓包工具会早于对应的应用接收到，便可以从客户端拿到对应的证书的公钥解密，读取到对应的数据。同时会将其自己公钥与服务器的公钥进行掉包，后续应用拿到的也是抓包工具的一个公钥。

  简单来说就是用户自己信任的工具作为了一个中间人在客户端和服务器之间。

## http 和 https 的区别及优缺点？

-  SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
-  http 协议的`默认端口`为 80，https 的默认端口为 443。
-  对网站服务器进行真实身份认证，对于搜索引擎更友好，利于SEO。
-  https会进行加密解密验证，开销更大

#### Http请求跨域

1. 何为跨域

   **跨域**，是指浏览器不能执行其他网站的脚本。它是由浏览器的`同源策略`造成的。
   **同源策略**，是浏览器对 JavaScript 实施的安全限制，只要`协议、域名、端口`有任何一个不同，都被当作是不同的域。
   **跨域原理**，即是通过各种方式，`避开浏览器的安全限制`。

2. 解决

   1. **JSONP**（只支持GET请求，需要后端配合）

      利用没有跨域限制的 script 标签加载预设的 callback 将内容传递给 服务器端，服务器调用对应的回调函数传递数据

      步骤

      1. 准备一个全局函数接收数据
      2. 客户端解析script标签，发出请求
      3. 服务端收到请求，返回函数的调用
      4. 客户端执行回调

      ```javascript
      function JSONP({
        url,
        params,
        callbackKey,
        callback
      }) {
        // 在参数里制定 callback 的名字
       params = params || {}
        params[callbackKey] = 'jsonpCallback'
       // 预留 callback
        window.jsonpCallback = callback
          // 拼接参数字符串
        const paramKeys = Object.keys(params)
        const paramString = paramKeys
          .map(key => `${key}=${params[key]}`)
          .join('&')
          // 插入 DOM 元素
        const script = document.createElement('script')
        script.setAttribute('src', `${url}?${paramString}`)
        document.body.appendChild(script)
      }

      JSONP({
        url: 'http://s.weibo.com/ajax/jsonp/suggestion',
        params: {
          key: 'test',
        },
        callbackKey: '_cb',
        callback(result) {
          console.log(result.data)
        }
      })
      ```

   2. **CORS(Cross-origin resource sharing)**:服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。

   3. **proxy代理** 目前常用方式,通过服务器设置代理

      1. 负载均衡，可以由代理服务器分发给不同的服务器，使得负载均衡。
      2. 缓存代理。可以减少对源服务器的请求。

## HTTP

HTTP协议规定了浏览器，即是万维网客户进程怎么样向万维网服务器请求万维网文档以及服务器怎么样发送文档到浏览器。从层次的角度看，它是面向事务的应用层协议。

`特点`：

- **「简单的」**。尽管HTTP2.0时将HTTP消息封装到了二进制的帧中，但HTTP大体上是被设计的简单易读的。
- **「灵活可扩展」**。HTTP1.0中新增的HEADERS，一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。所以只要客户端和服务器端两方商定好新的Header，那么新功能就可以很快被加入进来。
- **「请求-应答模式」**，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出响应等。
- **「可靠传输」**，HTTP是基于TCP/IP协议族，因此把这一特性继承了下来。
- **「无状态」**，对于发送过的请求都不做持久化处理。但HTTP/1.1引入了cookie技术

`缺点`：

- **「无状态」**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
- **「明文传输」**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
- **「队头阻塞」**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

请求报文组成：`请求行`，`请求头`，`请求体（只存在于POST请求方法下）`

![image-20220305093703123](/network/请求报文.png)

请求报文头：

- Client-IP：提供了运行客户端的机器的IP地址
- connection：连接方式
- keep-alive：长连接的设置
- if-Modified-since：协商缓存标志
- if-none-match：协商缓存标志
- Host：给出了接收请求的服务器的主机名和端口号
- Referer：提供了包含当前请求URI的文档的URL
- User-Agent：将发起请求的应用程序名称告知服务器
- Accept：告诉服务器能够发送哪些媒体类型
- Accept-Charset：告诉服务器能够发送哪些字符集
- Accept-Encoding：告诉服务器能够发送哪些编码方式
- Accept-Language：告诉服务器能够发送哪些语言
- Range：如果服务器支持范围请求，就请求资源的指定范围
- Cookie：客户端用它向服务器传送数据

响应报文组成：`响应头`，`相应行`，`响应体`

![image-20220305093739760](/network/响应报文.png)

响应报文头：

- Age：(从最初创建开始)响应持续时间
- connection：连接方式
- keep-alive：持久连接
- cache-control：强缓存
- last-modified：协商缓存
- etag：协商缓存标志
- Public：服务器为其资源支持的请求方法列表
- Server：服务器应用程序软件的名称和版本
- Title：对HTML文档来说，就是HTML文档的源端给出的标题
- Accept-Ranges：对此资源来说，服务器可接受的范围类型
- Vary：服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端
- Set-Cookie：在客户端设置数据，以便服务器对客户端进行标识

常用请求方法:

- HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
- HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

具体来说：

- GET：                请求获取Request-URI所标识的资源
- POST：              在Request-URI所标识的资源后附加新的数据
- HEAD：             请求获取由Request-URI所标识的资源的响应消息报头
- PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）
- DELETE：          请求服务器删除对应所标识的资源
- PATCH           对资源进行部分修改
- TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断
- CONNECT：      建立连接隧道，用于代理服务器
- OPTIONS：       列出可对资源实行的请求方法，用来跨域请求

问：GET 和 POST 的区别？

- 从`功能不同`看，GET请求更多是获取数据，POST请求被定义为新增数据。
- 从`缓存角度`看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- 从`参数角度`来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。同时get请求的最大长度是有限制的，通常在2K-8K。
- 从`编码角度`看，GET请求只能经行URL编码，而POST支持更多的编码类型且不对数据类型限值。
- 从`幂等性`看，GET请求幂等，POST请求不幂等。
- `tcp数据包区别`：GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。

幂等？

> 在开发中，幂等是指保证多次请求的一个接口返回的结果需要相同。服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

接口的幂等性实际上就是接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。有些接口可以天然的实现幂等性，比如查询接口，对于查询来说，你查询一次和两次，对于系统来说，没有任何影响，查出的结果也是一样。

幂等方法：在正确实现的条件下， GET ， HEAD ， PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。







问：options方法有什么用？

- OPTIONS 请求与 HEAD 类似，一般也是用于`客户端查看服务器的性能`。
- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以`测试服务器功能是否正常`。
- JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送`嗅探请求`，以判断是否有对指定资源的访问权限。

问：谈一谈队头阻塞？

- 首先，http是基于tcp/ip协议上建立的，为了提高效率不用每一次请求都建立tcp连接，便有了长连接（http/1.1默认；http/1.0需手动开启），一次建立tcp请求，多次复用。
- 但因为请求是逐个去请求的，所以在之前的请求响应回来之前，后续的请求无法进行，这就造成了队头阻塞（因为是前面的请求阻塞导致的）

问：如何解决队头阻塞？

- `管道化`：允许客户端在已发送的请求接收到服务端的响应之前发送下一个请求。  ===>   但是服务器端还是FIFO模式，并未完全解决。（现代浏览器默认已经不适用）
- `并发TCP连接`：每个域名2个连接（实际6-8个）

常见状态码：

| 状态码  |                                                |
| ------ | ---------------------------------------------- |
| 1xx    | 表示目前是协议处理的中间状态，还需要后续操作。 |
| 2xx    | 表示成功状态。                                 |
| 3xx    | 重定向状态，资源位置发生变动，需要重新请求。   |
| 4xx    | 请求报文有误。                                 |
| 5xx    | 服务器端发生错误。                             |

详解：

| 状态码  | 返回信息             | 说明                                                         |
| ------- | -------------------- | ------------------------------------------------------------ |
| 100     | Continue             | 表示目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略。                    |
| 101     | Switching Protocols  | 在`HTTP`升级为`WebSocket`的时候，如果服务器同意变更，就会发送状态码 101。(Connection: Upgrade   Upgrade: websocket)
 |
| 200     | OK                   | 成功状态码。通常在响应体中放有数据。                         |
| 204     | No Content           | 含义与 200 相同，但响应头后没有 body 数据。                  |
| 206     | Partial Content      | 表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段`Content-Range`。 |
| 301     | Moved Permanently    | 永久重定向，资源已经被分配了新的URL，搜索引擎应按照Location首部字段提示的URI重新保存。 |
| **302** | Found                | 临时重定向，浏览器会冲重定向到这个URL，但搜索引擎不会更正                                                   |
| 304     | Not Modified         | 当协商缓存命中时会返回这个状态码                             |
| 400     | Bad Request          | 通常是请求报文中出现了语法错误                               |
| 401     | Unauthorized         | 表示发送的请求需要被认证（未登陆、授权）                     |
| 403     | Forbidden            | 而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感，未获取访问权限（跨域！）。 |
| 404     | Not Found            | 资源未找到，表示没在服务器上找到相应的资源。                 |
| 405     | Method Not Allowed   | 请求方法不被服务器端允许。                                   |
| 500     | internal sever error | 服务器出错                                                   |
| 503     | Service Unavailable  | 服务器不可用。                                               |


### HTTP/0.9 - 单行协议

**请求**：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

**响应**：只包含响应文档本身。

此时的HTTP协议还未拥有HTTP头，这时只有HTML文件可以被传送；没有状态码和错误代码，当出现错误时候，一个包含错误信息的HTML文件会被返回并展示。


### HTTP/1.0 - 构建可扩展性

为了解决HTTP/0.9的问题，新增：

1. 协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）。
2. 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。
3. 引入了 HTTP 头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。
4. 在新 HTTP 头的帮助下，具备了传输除纯文本 HTML 文件以外其他类型文档的能力（凭借Content-Type头）。


### HTTP/1.1 - 标准化的协议

1999发布，主流的http协议版本。

- 引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 `keep-alive` 来设置

- 引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。

- HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since,If-modified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存。

- 响应分块。支持断点续传，通过使用请求头中的 `Range` 来实现(204 code)。

- 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。

版本问题:

- 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
- HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成`队头阻塞`。
- http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。
- 因为无状态特性，每一个连接都是新的连接。报文Header携带很多的头字段，可能会带来巨大的HTTP头部，导致传输性能的消耗。

### HTTP/2.0 - 更优异的表现

- `二进制分帧`  这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧；同时二进制数据更易于机器解析

帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。

消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。

流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。

流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。

在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。



- `头部压缩`  HTTP 1.1版本会出现 **「User-Agent、Cookie、Accept、Server、Range」** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 `HPACK` 算法进行压缩。

  头部压缩具体来说：


  - HPACK本身有一个表，里面有常用的headers，这个表称作**静态表**。其次静态表并不能完全表示所有可能需要用到的headers，所以客户端和服务器端也会维护一个**动态表**。他们组合在一起被称作**索引表**。
  - 在客户端和服务器端使用“索引表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送，而是发送索引，接收方可以查找索引表；
  - 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
  - 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值

- `多路复用` 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。

  因为只需要进行一次TCP连接，可以减少慢启动的次数。

- `服务器推送` 允许服务器未经请求，主动向客户端发送资源，即服务器推送。

  比如在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"`服务器推送`"（ Server Push，也叫 Cache push）


版本问题：

1. TCP 以及 TCP+TLS 建立连接的延时
2. TCP 的队头阻塞并没有彻底解决
3. 多路复用导致服务器压力上升
4. 多路复用容易 Timeout

### HTTP/3.0

- **实现了类似TCP的流量控制、传输可靠性的功能**
- **实现了快速握手功能**
- **集成了TLS加密功能**
- **多路复用，彻底解决TCP中队头阻塞的问题**
- **连接迁移**

### HTTP数据传输

1. 定长数据

   设置`Content-Length`,来指明发送数据的长度。

2. 不定长数据

   通常为Keep-alive状态设置`Transfer-Encoding: chunked`字段


### HTTP缓存

缓存可以提高客户端的请求响应速率，减轻服务器的压力。**缓存的正确操作对系统的稳定运行至关重要。**

#### 不同类型的缓存

**私有缓存**

私有缓存是绑定到特定客户端的缓存——**通常是浏览器缓存**。由于存储的响应不与其他客户端共享，因此私有缓存可以存储该用户的个性化响应。且不用担心用户的信息泄露。

```js
// 只允许私有缓存
Cache-Control: private;
```

**共享缓存**

共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为**代理缓存**和**托管缓存**。


1. **代理缓存**

除了访问控制的功能外，一些代理还实现了缓存以减少网络流量。这时客户端缓存失效之后就回去代理缓存中获取资源，代理缓存失效才会重新向源服务器进行请求。

```js
// 允许代理缓存
Cache-Control: public;
```

2. **托管缓存**

托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。示例包括反向代理、CDN 和 service worker 与缓存 API 的组合。

```js
// 代表不允许使用私有缓存和代理缓存
Cache-Control: no-store;
```
