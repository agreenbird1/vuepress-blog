---
title: HTTP/HTTPS协议
author: RoleTang
date: '2022-07-10'
---

#### HTTP/HTTPS

`http`: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
 `https`:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层（或者TSL）进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

**https的实现**

- 对称加密：采用协商的密钥对数据加密（传输数据，对称加密开销更小）
- 非对称加密：实现身份认证和密钥协商
- 摘要算法：验证信息的完整性
- 数字签名：身份验证

https如何认证实现？

- 为何不用对称加密？

非对称加密：公钥 <===> 私钥

例：TLS 1.2 握手过程

1. Client发起一个HTTPS请求，连接443端口，并携带自己可以进行连接的SSL版本号、支持的加密算法等。这个过程可以理解成是**「请求公钥的过程」**。

2. Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。

3. 浏览器本身会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。

   根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。

   通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。

4. 在安全拿到**「服务器公钥」**后，客户端Client随机生成一个**「对称密钥」**，使用**「服务器公钥」**（证书的公钥）加密这个**「对称密钥」**，发送给Server(服务器)。

5. Server(服务器)通过自己的私钥，对信息解密，至此得到了**「对称密钥」**，此时两者都拥有了相同的**「对称密钥」**。

##### http 和 https 的区别及优缺点？

-  SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
-  http 协议的`默认端口`为 80，https 的默认端口为 443。
-  对网站服务器进行真实身份认证，对于搜索引擎更友好，利于SEO。
-  https会进行加密解密验证，开销更大

ca证书的验证

- 客户端得到服务端返回的证书，通过读取得到 **服务端证书的发布机构（Issuer）**

- 客户端去操作系统查找这个发布机构的的证书，如果是不是根证书就继续递归下去 **直到拿到根证书**。

- 用 **根证书的公钥** 去 **解密验证** 上一层证书的**合法性**，再拿上一层证书的公钥去验证更上层证书的合法性；递归回溯。

- 最后验证服务器端的证书是 **可信任** 的。

#### Htttp请求跨域

1. 何为跨域

   **跨域**，是指浏览器不能执行其他网站的脚本。它是由浏览器的`同源策略`造成的。
   **同源策略**,是浏览器对 JavaScript 实施的安全限制，只要`协议、域名、端口`有任何一个不同，都被当作是不同的域。
   **跨域原理**，即是通过各种方式，`避开浏览器的安全限制`。

2. 解决

   1. **JSONP**（只支持GET请求，需要后端配合）

      利用没有跨域限制的 script 标签加载预设的 callback 将内容传递给 服务器端，服务器调用对应的回调函数传递数据

      步骤

      1. 准备一个全局函数接收数据
      2. 客户端解析script标签，发出请求
      3. 服务端收到请求，返回函数的调用
      4. 客户端执行回调

      ```javascript
      function JSONP({
        url,
        params,
        callbackKey,
        callback
      }) {
        // 在参数里制定 callback 的名字
       params = params || {}
        params[callbackKey] = 'jsonpCallback'
       // 预留 callback
        window.jsonpCallback = callback
          // 拼接参数字符串
        const paramKeys = Object.keys(params)
        const paramString = paramKeys
          .map(key => `${key}=${params[key]}`)
          .join('&')
          // 插入 DOM 元素
        const script = document.createElement('script')
        script.setAttribute('src', `${url}?${paramString}`)
        document.body.appendChild(script)
      }

      JSONP({
        url: 'http://s.weibo.com/ajax/jsonp/suggestion',
        params: {
          key: 'test',
        },
        callbackKey: '_cb',
        callback(result) {
          console.log(result.data)
        }
      })
      ```

   2. **CORS(Cross-origin resource sharing)**:服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。

   3. **proxy代理** 目前常用方式,通过服务器设置代理

      1. 负载均衡，可以由代理服务器分发给不同的服务器，使得负载均衡。
      2. 缓存代理。可以减少对源服务器的请求。

#### HTTP

HTTP协议规定了浏览器，即是万维网客户进程怎么样向万维网服务器请求万维网文档以及服务器怎么样发送文档到浏览器。从层次的角度看，它是面向事务的应用层协议。

`特点`：

- **「灵活可扩展」**。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
- **「请求-应答模式」**，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出响应等。
- **「可靠传输」**，HTTP是基于TCP/IP协议族，因此把这一特性继承了下来。
- **「无状态」**，对于发送过的请求都不做持久化处理。但HTTP/1.1引入了cookie技术

`缺点`：

- **「无状态」**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
- **「明文传输」**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
- **「队头阻塞」**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

请求报文组成：`请求行`，`请求头`，`请求体（只存在于POST请求方法下）`

![image-20220305093703123](/network/请求报文.png)

请求报文头：

- Client-IP：提供了运行客户端的机器的IP地址
- connection：连接方式
- if-Modified-since：协商缓存标志
- if-none-match：协商缓存标志
- Host：给出了接收请求的服务器的主机名和端口号
- Referer：提供了包含当前请求URI的文档的URL
- User-Agent：将发起请求的应用程序名称告知服务器
- Accept：告诉服务器能够发送哪些媒体类型
- Accept-Charset：告诉服务器能够发送哪些字符集
- Accept-Encoding：告诉服务器能够发送哪些编码方式
- Accept-Language：告诉服务器能够发送哪些语言
- Range：如果服务器支持范围请求，就请求资源的指定范围
- Cookie：客户端用它向服务器传送数据

响应报文组成：`响应头`，`相应行`，`响应体`

![image-20220305093739760](/network/响应报文.png)

响应报文头：

- Age：(从最初创建开始)响应持续时间
- connection：连接方式
- keep-alive：持久连接
- cache-control：强缓存
- last-modefied：协商缓存
- etag：协商缓存标志
- Public：服务器为其资源支持的请求方法列表
- Server：服务器应用程序软件的名称和版本
- Title：对HTML文档来说，就是HTML文档的源端给出的标题
- Accept-Ranges：对此资源来说，服务器可接受的范围类型
- Vary：服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端
- Set-Cookie：在客户端设置数据，以便服务器对客户端进行标识

常用请求方法:

- HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
- HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

具体来说：

- GET：                请求获取Request-URI所标识的资源
- POST：              在Request-URI所标识的资源后附加新的数据
- HEAD：             请求获取由Request-URI所标识的资源的响应消息报头
- PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）
- DELETE：          请求服务器删除对应所标识的资源
- TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断
- CONNECT：      建立连接隧道，用于代理服务器
- OPTIONS：       列出可对资源实行的请求方法，用来跨域请求

问：GET 和 POST 的区别？

- 从`缓存角度`看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- 从`参数角度`来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。
- 从`编码角度`看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。
- GET`请求幂等`，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致（不改变资源，知识获取）。
- `tcp数据包区别`：GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。

问：options方法有什么用？

- OPTIONS 请求与 HEAD 类似，一般也是用于`客户端查看服务器的性能`。
- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以`测试服务器功能是否正常`。
- JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送`嗅探请求`，以判断是否有对指定资源的访问权限。

问：谈一谈队头阻塞？

- 首先，http是基于tcp/ip协议上建立的，为了提高效率不用每一次请求都建立tcp连接，便有了长连接（http/1.1默认；http/1.0需手动开启），一次建立tcp请求，多次复用。
- 但因为请求是逐个去请求的，所以在之前的请求响应回来之前，后续的请求无法进行，这就造成了队头阻塞（因为是前面的请求阻塞导致的）

问：如何解决队头阻塞？

- `管道化`：允许客户端在已发送的请求接收到服务端的响应之前发送下一个请求。  ===>   但是服务器端还是FIFO模式，并未完全解决。（现代浏览器默认已经不适用）
- `并发TCP连接`：每个域名2个连接（实际6-8个）

常见状态码：

| 状态码  |                                                |
| ------ | ---------------------------------------------- |
| 1xx    | 表示目前是协议处理的中间状态，还需要后续操作。 |
| 2xx    | 表示成功状态。                                 |
| 3xx    | 重定向状态，资源位置发生变动，需要重新请求。   |
| 4xx    | 请求报文有误。                                 |
| 5xx    | 服务器端发生错误。                             |

详解：

| 状态码  | 返回信息             | 说明                                                         |
| ------- | -------------------- | ------------------------------------------------------------ |
| 100     | Continue             | post方法发送请求头之后就会返回，意味继续                     |
| 101     | Switching Protocols  | 在`HTTP`升级为`WebSocket`的时候，如果服务器同意变更，就会发送状态码 101。 |
| 200     | OK                   | 成功状态码。通常在响应体中放有数据。                         |
| 204     | No Content           | 含义与 200 相同，但响应头后没有 body 数据。                  |
| 206     | Partial Content      | 表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段`Content-Range`。 |
| 301     | Moved Permanently    | 永久重定向，资源已经被分配了新的URL，应按照Location首部字段提示的URI重新保存。 |
| **302** | Found                | 临时重定向                                                   |
| 304     | Not Modified         | 当协商缓存命中时会返回这个状态码                             |
| 400     | Bad Request          | 通常是请求报文中出现了语法错误                               |
| 401     | Unauthorized         | 表示发送的请求需要被认证（未登陆、授权）                     |
| 403     | Forbidden            | 而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感，未获取访问权限（跨域！）。 |
| 404     | Not Found            | 资源未找到，表示没在服务器上找到相应的资源。                 |
| 405     | Method Not Allowed   | 请求方法不被服务器端允许。                                   |
| 500     | internal sever error | 服务器出错                                                   |
| 503     | Service Unavailable  | 服务器不可用。                                               |



##### HTTP/1.1

1999发布，主流的http协议版本。

- 引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 `keep-alive` 来设置

- 引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。

- HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存。

- 支持断点续传，通过使用请求头中的 `Range` 来实现。

- 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。

版本问题:

- 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
- HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成`队头阻塞`。
- http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。
- 因为无状态特性，每一个连接都是新的连接。报文Header携带很多的头字段，可能会带来巨大的HTTP头部，导致传输性能的消耗。

##### HTTP/2.0

- `二进制分帧`  这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧；同时二进制数据更易于机器解析

  它把TCP协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame),用"`HEADERS`"帧存放头数据、"`DATA`"帧存放实体数据。HTTP/2.0数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。


  HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。**多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装** ==> `Stream ID`。

- `头部压缩`  HTTP 1.1版本会出现 **「User-Agent、Cookie、Accept、Server、Range」** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 `HPACK` 算法进行压缩（哈夫曼算法）。

  头部压缩具体来说：

  - 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送，而是发送索引，接收方可以查找索引表；
  - 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
  - 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值

- `多路复用` 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。

  因为只需要进行一次TCP连接，可以减少慢启动的次数。

- `服务器推送` 允许服务器未经请求，主动向客户端发送资源，即服务器推送。

  比如在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"`服务器推送`"（ Server Push，也叫 Cache push）


版本问题：

1. TCP 以及 TCP+TLS 建立连接的延时
2. TCP 的队头阻塞并没有彻底解决
3. 多路复用导致服务器压力上升
4. 多路复用容易 Timeout

##### HTTP/3.0

- **实现了类似TCP的流量控制、传输可靠性的功能**
- **实现了快速握手功能**
- **集成了TLS加密功能**
- **多路复用，彻底解决TCP中队头阻塞的问题**
- **连接迁移**

##### Http数据传输

1. 定长数据

   设置`Content-Length`,来指明发送数据的长度。

2. 不定长数据

   通常为Keep-alive状态设置`Transfer-Encoding: chunked`字段

