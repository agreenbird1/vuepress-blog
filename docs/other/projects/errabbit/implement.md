---
title: 项目实现
author: RoleTang
date: '2022-07-26'
---


- 第三方登陆

  第一步，获取appkey和appid

  1. 首先网站需要备案，并包含qq登陆的逻辑
  2. 需要在qq互联上进行身份认证，审核通过
  3. 然后再在qq互联上创建应用，应用需要域名，备案号，回调地址
  4. 得到appkey和appid

  第二步，放置qq登陆按钮，编写tologin函数

  第三步，用户授权，并回跳页面，同时获得用户的openId

  第四步，便可以通过用户的openId查询是否注册，进行相关操作

- 面包屑组件

  面包屑组件基本结构

  ```vue
    <!-- 面包屑 -->
  <XtxBread>
      <XtxBreadItem to="/">首页</XtxBreadItem>
       <XtxBreadItem to="/category/1005000">电器</XtxBreadItem>
      <XtxBreadItem >空调</XtxBreadItem>
  </XtxBread>
  ```

  通过XtxBread组件中进行动态渲染。根据`this.$slots.default()`拿到面包屑中的内容，即是嵌入的item组件。根据组件的数量添加一个向右的箭头，然后进行动态的渲染。

  根据url路径中的参数与动态添加对应的breadItem，并在bread组件中渲染。

- vee-validate的使用

  直接引入form和field组件

  同时绑定一个校验对象validation-schema到form组件，其中校验函数需要和field的name字段对应。然后使用即可。



- 自定义指令 **directive**

  IntersectionObserver()构造函数语法

  `var observer = new IntersectionObserver(callback[, options]);`

  callback会接收一个**IntersectionObserverEntry**的数组对象，解构可以得到一个isIntersecting的参数，它即是是否进入可视区的Boolean值。

  options中设置threshold参数为0，意思是被观察元素与视口一相交就调用回调。

  返回的observer可以使用observe和unobserve方法开启和取消观察。

  自定义指令通过 app.directive实现，

  `第一个参数`即为指令名，但需要加上v-（比如lazy，应用时候就是v-lazy）

  `第二个参数`即是配置对象，需要一个mounted函数（其实有很多钩子，类似于生命周期函数），此函数接收两个对象，被绑定的dom本身（el），以及第二个参数  动态参数，比如

  `v-lazy='img.picture'`，那么此属性便会被传递到mounted函数的第二个参数。



  综上，当触发observer对象的回调的时候，可以判断是否进入可视区，进入之后可以将将图片的路径设置在其src属性上

  `el.src = binding.value`，实现懒加载。

- 数据懒加载的实现

  数据懒加载实际上也是使用的IntersectionObserver接口，当时主要是为了了解一下@vueuse/core这个工具库函数。

  需要什么，既然是一个数据懒加载的钩子函数，那么肯定需要请求数据的函数。

  做了什么，在合适的时候请求数据

  返回请求函数的结果，返回需要被监视的对象（即是target，useIntersectionObserver需要的参数），将参数绑定到被监视的dom元素上即可。（结果和对象都是响应式的，这样才能动态监听）

- 购物车的实现，全选反选等

  存储商品数据有一个selected属性。使用getters返回我需要的数据，比如总共多少件？已选多少件？

  如果是本地，直接找到对应的商品修改它的selected属性

  如果是已经登陆，则发送请求给服务器然后服务器修改了我再申请新数据即可。

- 本地购物车合并

  在登陆之后会保存当前本地购物车内商品的主要信息。包括：id、数量、以及是否选中。

  然后清空本地，当跳转到主页的时候会重新请求资源。

- 上拉加载数据

  兼容性差的情况下使用 `srcoll` 事件监听 + 节流的方法实现。

  ```js
  scrollTop+clientHeight > offsetTop
  ```

- 自定义组件

  一般来说就是进行props传递参数。

  然后根据对应的数据进行一个展示。同时需要进行一些数据的切换。甚至是可能用到**插槽**，组件的自定义事件（emit）



- 看element-plus源码学习到了什么？

  大量的hooks的复用，比如常用的use-namespace

  用到了一些公共的方法，比如clickoutside

  多抽离复用的思想



- 商品详情中点击其他的商品如何实现

  使用watch，监视路由的id（动态路由匹配）

- ==spu&sku的实现：根据点击的规格实现禁用和点击效果==

  介绍spu、sku的概念

  `spu`：是对商品属性的描述。具有什么样的属性，包括颜色、大小等等

  `sku`：就是对商品属性具体的描述。比如红色、巨大等。

  首先需要确认后端返回的数据的格式嘛，大概说一下思路。

  后端数据返回的是所有的的sku以及对应的库存，筛选出剩余库存大于0的sku

  需要拿到之后进行子集计算。

  首先，根据数据可以计算所有的排列组合（规格组合，会有库存和skuid）

  再将拥有的规格的子集（幂集）拆分（使用JavaScript-algorithms中的power-set函数实现）

  其次将所有的子集装入对象（路径字典），键为子集中的规格，值为skuid

  初始化时候，对每一个规格设置disabled属性。拿到路径字典，对所有的规格进行遍历。创建一个空数组并去对应位置填充，判断没被选择的规格是否能被选择，再拿到拼接的路径去路径字典进行判断，有则设置为true。

  两个需求：

  1. 当点击的时候判断其他规格是否可点。在每一个按钮的数据上添加一个disabled属性，初始化数据的时候进行一次设置。若路径字典中有数据，则设置为真。当点击一个规格之后，

     则去遍历规格数组，同时创建一个新的对应长度（与属性数目相同）的数组。遍历的时候将对应的位置的规格属性加入到新创建的数组，并去字典中查找，找到了设置为true。

  2. 初始化的时候便进行一个遍历，禁用不可选的规格


- 自定义确认提示框组件如何实现的？

  首先是准备一个静态页面

  首先创建一个真实dom，用于挂载在document上充当容器。

  然后暴露一个方法，方法接收两个参数，确认框的文字和标题，并返回一个Promise。并通过createVNode方法创建一个vnode，并通过render函数渲染到真实dom上。当点击确定的时候调用两个函数，分别执行resolve和reject，这样可以来判断用户点击的状态。

  `createVNode`：其实就是生成一个组件的实例（VNode）。在这里其实就是对应的静态组件的实例。（1参数：组件、2参数：props、三参数：children）

  render：渲染组件，将组件实例挂载到真实dom

- 消息提示框的动画实现

  使用vue的动画即可，进入离开

- 上拉加载更多

  此组件都是在父级组件的下方。

  依然是使用的useIntersectionObserver库函数。传递两个props，loading和finished。当达到可视区触发的时候便触发一个事件使父组件请求数据，并根据是否还有数据进行改变finished的值。

- 放大镜组件的实现

  useMouseInElement库函数，该函数可以监听鼠标在被绑定元素中的位置。通过鼠标在图片中的位置来设置遮罩层和右边大图的位置。

  被查看的图片中的遮罩层宽高是原本图片的一半（absolute布局）

  大图的宽高是原本的图片的宽高的两倍（absolute布局）

  大图通过background-position-x和background-position-y进行实现。因为其移动方向的距离只能是原本图片的宽高，所以与遮罩层的移动具有两倍的关系。

  比如遮罩层大小200，原图400，大图800。对应的距离为200，大图为400即可。

- ==分页器组件的实现==

  首先你得知道需要哪些参数？

  比如目前在第几页？总共的数据？一页有多少？当然还可以指定中间连续的页码有多少？这些都可以设置为props参数

  1. 这里分页器主要是有首尾两页以及中间连续的页码构成的，并且主要的边界计算都是集中于中间部分的连续页码。
  2. 首页当然是第一页，如果没有数据分页器甚至不会展示。同时尾页就是总页数，即是总数目除以一页的数目，并向上取整。
  3. 此时可以获取连续页码，比如连续页指定为五页，那么当前页一般来说就是中间那一页。对于连续页码来说，第一页就为当前页减2，最后一页为首页加上连续页码数减一。
  4. 其次，需要判断首尾边界。当起始页小于等于1的时候，start就只能等于2。然后判断尾页，最后一页若大于等于尾页，就等于尾页的值减一。
  5. 然后根据连续页码的起始和结束页对连续页码进行填充即可。
  6. 同时加上一些其他的判断，比如当页码数较多，需要显示过渡，比如中间的小点，那么还需要加入一些其他的边界判断。